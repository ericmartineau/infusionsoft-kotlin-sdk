/**
* Infusionsoft REST API
* No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
*
* OpenAPI spec version: 1.70.0.78606
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.mverse.client.infusionsoft.apis

import io.mverse.client.infusionsoft.models.EmailSendRequest
import io.mverse.client.infusionsoft.models.EmailSentCreate
import io.mverse.client.infusionsoft.models.EmailSentCreateList
import io.mverse.client.infusionsoft.models.EmailSentQueryResultList
import io.mverse.client.infusionsoft.models.EmailSentQueryResultWithContent
import io.mverse.client.infusionsoft.models.Error
import io.mverse.client.infusionsoft.models.SetOfIds

import io.mverse.client.infusionsoft.infrastructure.*
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken

    interface EmailApi {

        /**
        *  Create an Email Record
        *  Create a record of an email sent to a contact
        *  * @param emailWithContent Email records to persist, with content. (optional)
        *  * @return EmailSentCreate
        */
        fun createEmail(emailWithContent: EmailSentCreate? = null) : EmailSentCreate
        /**
        *  Create a set of Email Records
        *  Create a set of records of emails sent to contacts, maximum 1000 per transaction.
        *  * @param emailWithContent Email records to persist, with content. (optional)
        *  * @return EmailSentCreateList
        */
        fun createEmails(emailWithContent: EmailSentCreateList? = null) : EmailSentCreateList
        /**
        *  Delete an Email Record
        *  Delete a specific email record
        *  * @param id id 
        *  * @return void
        */
        fun deleteEmail(id: Long) : Unit
        /**
        *  Un-sync a batch of Email Records
        *  Un-syncs a batch of email records
        *  * @param emailIds emailIds 
        *  * @return Map<kotlin.String, String>
        */
        fun deleteEmails(emailIds: SetOfIds) : Map<kotlin.String, String>
        /**
        *  Retrieve an Email
        *  Retrieves a single email that has been sent
        *  * @param id id 
        *  * @return EmailSentQueryResultWithContent
        */
        fun getEmail(id: Long) : EmailSentQueryResultWithContent
        /**
        *  List Emails
        *  Retrieve a list of emails that have been sent
        *  * @param limit Sets a total of items to return (optional)
        *  * @param offset Sets a beginning range of items to return (optional)
        *  * @param contactId Optional Contact Id to find Emails for (optional)
        *  * @param email Optional email address to query on (optional)
        *  * @param sinceSentDate Optional date to query on, emails sent since the provided date, must be present if untilDate is provided (optional)
        *  * @param untilSentDate Optional date to query on, email sent until the provided date (optional)
        *  * @return EmailSentQueryResultList
        */
        fun listEmails(limit: Int? = null, offset: Int? = null, contactId: Long? = null, email: String? = null, sinceSentDate: String? = null, untilSentDate: String? = null) : EmailSentQueryResultList
        /**
        *  Send an Email
        *  Send an Email to a list of Contacts
        *  * @param emailSendRequest emailSendRequest (optional)
        *  * @return void
        */
        fun sendEmail(emailSendRequest: EmailSendRequest? = null) : Unit
        /**
        *  Update an Email Record
        *  Update a record of an email sent to a contact
        *  * @param id id 
        *  * @param emailWithContent Email records to persist, with content. (optional)
        *  * @return EmailSentCreate
        */
        fun updateEmail(id: Long, emailWithContent: EmailSentCreate? = null) : EmailSentCreate
    }

class EmailApiImpl(bearerToken:String, basePath: String, gson: Gson) : EmailApi, ApiClient(basePath, bearerToken, gson) {

  /**
   *  Create an Email Record
   *  Create a record of an email sent to a contact
   *  * @param emailWithContent Email records to persist, with content. (optional)
   *  * @return EmailSentCreate
   */ 
  @Suppress("UNCHECKED_CAST")
  override fun createEmail(emailWithContent: EmailSentCreate?) : EmailSentCreate {
    val requestBody = emailWithContent
    val localVariableQuery: MultiValueMap = mutableMapOf()

    val contentHeaders: Map<String, String> = mapOf()
    val acceptsHeaders: Map<String, String> = mapOf("Accept" to "application/json")
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders.putAll(contentHeaders)
    localVariableHeaders.putAll(acceptsHeaders)

    val localVariableConfig = RequestConfig(
       RequestMethod.POST,
       "/emails",
       query = localVariableQuery,
       headers = localVariableHeaders
    )
    val response = request(localVariableConfig, requestBody)

    return when (response) {
      is Success -> gson.fromJson(response.data, object : TypeToken<EmailSentCreate>() {}.type)
      is Informational -> TODO()
      is Redirection -> TODO()
      is ClientError -> throw ClientException(response.body as? String ?: "Client error")
      is ServerError -> throw ServerException(response.message ?: "Server error")
      else -> throw IllegalStateException("Undefined ResponseType.")
    }
  }
  /**
   *  Create a set of Email Records
   *  Create a set of records of emails sent to contacts, maximum 1000 per transaction.
   *  * @param emailWithContent Email records to persist, with content. (optional)
   *  * @return EmailSentCreateList
   */ 
  @Suppress("UNCHECKED_CAST")
  override fun createEmails(emailWithContent: EmailSentCreateList?) : EmailSentCreateList {
    val requestBody = emailWithContent
    val localVariableQuery: MultiValueMap = mutableMapOf()

    val contentHeaders: Map<String, String> = mapOf()
    val acceptsHeaders: Map<String, String> = mapOf("Accept" to "application/json")
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders.putAll(contentHeaders)
    localVariableHeaders.putAll(acceptsHeaders)

    val localVariableConfig = RequestConfig(
       RequestMethod.POST,
       "/emails/sync",
       query = localVariableQuery,
       headers = localVariableHeaders
    )
    val response = request(localVariableConfig, requestBody)

    return when (response) {
      is Success -> gson.fromJson(response.data, object : TypeToken<EmailSentCreateList>() {}.type)
      is Informational -> TODO()
      is Redirection -> TODO()
      is ClientError -> throw ClientException(response.body as? String ?: "Client error")
      is ServerError -> throw ServerException(response.message ?: "Server error")
      else -> throw IllegalStateException("Undefined ResponseType.")
    }
  }
  /**
   *  Delete an Email Record
   *  Delete a specific email record
   *  * @param id id 
   *  * @return void
   */ 
  override fun deleteEmail(id: Long) : Unit {
    val requestBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()

    val contentHeaders: Map<String, String> = mapOf()
    val acceptsHeaders: Map<String, String> = mapOf("Accept" to "application/json")
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders.putAll(contentHeaders)
    localVariableHeaders.putAll(acceptsHeaders)

    val localVariableConfig = RequestConfig(
       RequestMethod.DELETE,
       "/emails/{id}".replace("{"+"id"+"}", "$id"),
       query = localVariableQuery,
       headers = localVariableHeaders
    )
    val response = request(localVariableConfig, requestBody)

    return when (response) {
      is Success -> gson.fromJson(response.data, object : TypeToken<Unit>() {}.type)
      is Informational -> TODO()
      is Redirection -> TODO()
      is ClientError -> throw ClientException(response.body as? String ?: "Client error")
      is ServerError -> throw ServerException(response.message ?: "Server error")
      else -> throw IllegalStateException("Undefined ResponseType.")
    }
  }
  /**
   *  Un-sync a batch of Email Records
   *  Un-syncs a batch of email records
   *  * @param emailIds emailIds 
   *  * @return Map<kotlin.String, String>
   */ 
  @Suppress("UNCHECKED_CAST")
  override fun deleteEmails(emailIds: SetOfIds) : Map<kotlin.String, String> {
    val requestBody = emailIds
    val localVariableQuery: MultiValueMap = mutableMapOf()

    val contentHeaders: Map<String, String> = mapOf()
    val acceptsHeaders: Map<String, String> = mapOf("Accept" to "application/json")
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders.putAll(contentHeaders)
    localVariableHeaders.putAll(acceptsHeaders)

    val localVariableConfig = RequestConfig(
       RequestMethod.POST,
       "/emails/unsync",
       query = localVariableQuery,
       headers = localVariableHeaders
    )
    val response = request(localVariableConfig, requestBody)

    return when (response) {
      is Success -> gson.fromJson(response.data, object : TypeToken<Map<kotlin.String, String>>() {}.type)
      is Informational -> TODO()
      is Redirection -> TODO()
      is ClientError -> throw ClientException(response.body as? String ?: "Client error")
      is ServerError -> throw ServerException(response.message ?: "Server error")
      else -> throw IllegalStateException("Undefined ResponseType.")
    }
  }
  /**
   *  Retrieve an Email
   *  Retrieves a single email that has been sent
   *  * @param id id 
   *  * @return EmailSentQueryResultWithContent
   */ 
  @Suppress("UNCHECKED_CAST")
  override fun getEmail(id: Long) : EmailSentQueryResultWithContent {
    val requestBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()

    val contentHeaders: Map<String, String> = mapOf()
    val acceptsHeaders: Map<String, String> = mapOf("Accept" to "application/json")
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders.putAll(contentHeaders)
    localVariableHeaders.putAll(acceptsHeaders)

    val localVariableConfig = RequestConfig(
       RequestMethod.GET,
       "/emails/{id}".replace("{"+"id"+"}", "$id"),
       query = localVariableQuery,
       headers = localVariableHeaders
    )
    val response = request(localVariableConfig, requestBody)

    return when (response) {
      is Success -> gson.fromJson(response.data, object : TypeToken<EmailSentQueryResultWithContent>() {}.type)
      is Informational -> TODO()
      is Redirection -> TODO()
      is ClientError -> throw ClientException(response.body as? String ?: "Client error")
      is ServerError -> throw ServerException(response.message ?: "Server error")
      else -> throw IllegalStateException("Undefined ResponseType.")
    }
  }
  /**
   *  List Emails
   *  Retrieve a list of emails that have been sent
   *  * @param limit Sets a total of items to return (optional)
   *  * @param offset Sets a beginning range of items to return (optional)
   *  * @param contactId Optional Contact Id to find Emails for (optional)
   *  * @param email Optional email address to query on (optional)
   *  * @param sinceSentDate Optional date to query on, emails sent since the provided date, must be present if untilDate is provided (optional)
   *  * @param untilSentDate Optional date to query on, email sent until the provided date (optional)
   *  * @return EmailSentQueryResultList
   */ 
  @Suppress("UNCHECKED_CAST")
  override fun listEmails(limit: Int?, offset: Int?, contactId: Long?, email: String?, sinceSentDate: String?, untilSentDate: String?) : EmailSentQueryResultList {
    val requestBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    if (limit != null) localVariableQuery["limit"] = listOf("$limit")
    if (offset != null) localVariableQuery["offset"] = listOf("$offset")
    if (contactId != null) localVariableQuery["contact_id"] = listOf("$contactId")
    if (email != null) localVariableQuery["email"] = listOf("$email")
    if (sinceSentDate != null) localVariableQuery["since_sent_date"] = listOf("$sinceSentDate")
    if (untilSentDate != null) localVariableQuery["until_sent_date"] = listOf("$untilSentDate")

    val contentHeaders: Map<String, String> = mapOf()
    val acceptsHeaders: Map<String, String> = mapOf("Accept" to "application/json")
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders.putAll(contentHeaders)
    localVariableHeaders.putAll(acceptsHeaders)

    val localVariableConfig = RequestConfig(
       RequestMethod.GET,
       "/emails",
       query = localVariableQuery,
       headers = localVariableHeaders
    )
    val response = request(localVariableConfig, requestBody)

    return when (response) {
      is Success -> gson.fromJson(response.data, object : TypeToken<EmailSentQueryResultList>() {}.type)
      is Informational -> TODO()
      is Redirection -> TODO()
      is ClientError -> throw ClientException(response.body as? String ?: "Client error")
      is ServerError -> throw ServerException(response.message ?: "Server error")
      else -> throw IllegalStateException("Undefined ResponseType.")
    }
  }
  /**
   *  Send an Email
   *  Send an Email to a list of Contacts
   *  * @param emailSendRequest emailSendRequest (optional)
   *  * @return void
   */ 
  override fun sendEmail(emailSendRequest: EmailSendRequest?) : Unit {
    val requestBody = emailSendRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()

    val contentHeaders: Map<String, String> = mapOf()
    val acceptsHeaders: Map<String, String> = mapOf("Accept" to "application/json")
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders.putAll(contentHeaders)
    localVariableHeaders.putAll(acceptsHeaders)

    val localVariableConfig = RequestConfig(
       RequestMethod.POST,
       "/emails/queue",
       query = localVariableQuery,
       headers = localVariableHeaders
    )
    val response = request(localVariableConfig, requestBody)

    return when (response) {
      is Success -> gson.fromJson(response.data, object : TypeToken<Unit>() {}.type)
      is Informational -> TODO()
      is Redirection -> TODO()
      is ClientError -> throw ClientException(response.body as? String ?: "Client error")
      is ServerError -> throw ServerException(response.message ?: "Server error")
      else -> throw IllegalStateException("Undefined ResponseType.")
    }
  }
  /**
   *  Update an Email Record
   *  Update a record of an email sent to a contact
   *  * @param id id 
   *  * @param emailWithContent Email records to persist, with content. (optional)
   *  * @return EmailSentCreate
   */ 
  @Suppress("UNCHECKED_CAST")
  override fun updateEmail(id: Long, emailWithContent: EmailSentCreate?) : EmailSentCreate {
    val requestBody = emailWithContent
    val localVariableQuery: MultiValueMap = mutableMapOf()

    val contentHeaders: Map<String, String> = mapOf()
    val acceptsHeaders: Map<String, String> = mapOf("Accept" to "application/json")
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders.putAll(contentHeaders)
    localVariableHeaders.putAll(acceptsHeaders)

    val localVariableConfig = RequestConfig(
       RequestMethod.PUT,
       "/emails/{id}".replace("{"+"id"+"}", "$id"),
       query = localVariableQuery,
       headers = localVariableHeaders
    )
    val response = request(localVariableConfig, requestBody)

    return when (response) {
      is Success -> gson.fromJson(response.data, object : TypeToken<EmailSentCreate>() {}.type)
      is Informational -> TODO()
      is Redirection -> TODO()
      is ClientError -> throw ClientException(response.body as? String ?: "Client error")
      is ServerError -> throw ServerException(response.message ?: "Server error")
      else -> throw IllegalStateException("Undefined ResponseType.")
    }
  }
}

